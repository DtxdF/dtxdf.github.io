<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Otro blog rand(3)</title><link>https://dtxdf.github.io</link><description>Desde UTC-04:00 tecleando a lo loco</description><pubDate>Sat, 12 Apr 2025 00:00:00 GMT</pubDate><lastBuildDate>Sat, 13 Sep 2025 19:19:45 GMT</lastBuildDate><generator>marmite</generator><item><title>Smart Timeouts</title><link>https://dtxdf.github.io/smart-timeouts.html</link><category>overlord</category><category>timeout</category><category>smart timeout</category><category>timeout strategy</category><category>distributed system</category><guid>https://dtxdf.github.io/smart-timeouts.html</guid><pubDate>Sat, 12 Apr 2025 00:00:00 GMT</pubDate><source url="https://dtxdf.github.io">tag-timeout</source><content:encoded><![CDATA[<p><em>Smart Timeouts</em> es una feature de <a href="https://github.com/DtxdF/overlord">Overlord</a> bastante simple, pero que me ha demostrado ser eficaz. Aunque la arquitectura de Overlord, la cual es un árbol encadenado (inspirado de alguna manera por DNS), es simple pero escala muy bien, eso trae el inconveniente de que un fallo en la <em>cadena C</em> puede ralentizar la <em>cadena B</em> y <em>A</em>. Al menos el cliente verá un error, pero no sin esperar unos segundos valiosos.</p>
<p>Continuando, la idea de esta feature es deshabilitar la cadena que esté fallando, y está solo puede ser la cadena final (o la cola), o <em>&quot;la cadena C&quot;</em>. Esto al menos se debe realizar desde la <em>cadena B</em>. Al igual que el <em>timeout</em> se propaga, esta deshabilitación de la cola trae consigo el beneficio de que, dado que no se está intentando conectar a una cadena fallando, no generará un <em>timeout</em> por lo que todo el sistema se verá beneficiado, ahorrando unos buenos recursos, más si está sobrecargado.</p>
<p>Suponiendo una lista de cadenas inicial <code>A -&gt; B -&gt; C</code>, el cliente intentará conectarse (indirectamente a través de las propias cadenas) a todas las cadenas para usar sus recursos. Todas las cadenas continúan operando con normalidad, pero repentinamente la <em>cadena C</em> falla por cualquier razón. El cliente ve el ejemplo luego de unos segundos. La <em>cadena B</em> sabe que hubo un fallo y dependiendo de cuanto sea la tolerancia, pondrá la cadena fallando en una lista negra por un periodo de tiempo configurable. Sin embargo, este periodo de tiempo configurable en el que la cadena fallando puede estar puede no ser suficiente, dado que tal vez el problema de la <em>cadena C</em> (la cadena fallando) puede persistir por un largo tiempo, así que cuando finalice el tiempo en el que esa cadena estará en la lista negra, el cliente se intentará conectar nuevamente sin éxito, lo cual pondrá nuevamente la cadena fallando en la lista negra, pero es donde se incrementa el tiempo hasta un máximo configurable. Así hasta que la cadena que esté fallando vuelva a la vida.</p>
<p>Esto no quiere decir que el <em>timeout</em> se ha eliminado, no tendría sentido, es mejor arreglar el problema de la cadena fallando o simplemente configurar Overlord para eliminar o deshabilitar la cadena.</p>
<p>Así de simple funcionan los <em>Smart Timeouts</em> en un sistema distribuido como Overlord.</p>
]]></content:encoded></item></channel></rss>